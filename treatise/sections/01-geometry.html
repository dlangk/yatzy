<section id="part-i">
  <div class="part-title">Part I</div>
  <h2>The Geometry of a Game</h2>

  <p>
    Every game of Yatzy traces a path through a vast, invisible space. To solve
    the game, we first need to map that space &mdash; to understand its shape, its
    size, and the structure that makes computation feasible.
  </p>

  <h3>The State Space</h3>

  <p>
    A Yatzy game has fifteen rounds. In each round, the player assigns a dice
    result to one of the fifteen categories. The categories split into two
    sections: six upper categories (Ones through Sixes) and nine lower categories
    (One Pair through Yatzy). A running tally of the upper-section total determines
    whether the player earns a 50-point
    <span class="concept" data-concept="upper-section-bonus">bonus</span> at the
    end (the threshold is 63 points, equivalent to three of each die face).
  </p>

  <p>
    The <span class="concept" data-concept="state-space">state</span> of the game
    at any point between turns is fully described by two quantities: the upper-section
    score so far (an integer from 0 to 63, since any value above the threshold is
    equivalent), and the set of categories already used (a subset of fifteen elements).
    This gives a theoretical space of 64 &times; 2<sup>15</sup> = 2,097,152 slots,
    arranged as a grid where one axis counts points and the other encodes a bitmask
    of scored categories.
  </p>

  <div class="chart-container" id="chart-state-space-counter">
    <div class="scroll-sticky" id="counter-sticky">
      <div id="counter-display"></div>
    </div>
    <div class="scroll-steps" id="counter-steps">
      <div class="step" data-step="0"><p>Fifteen categories, each scored or not — 2<sup>15</sup> = 32,768 possible scorecards.</p></div>
      <div class="step" data-step="1"><p>Each scorecard combined with an upper-section total (0–63) — now 2,097,152 slots.</p></div>
      <div class="step" data-step="2"><p>Forward reachability prunes 31.8% of these. The solver evaluates 1,430,000 states.</p></div>
      <div class="step" data-step="3"><p>Within each state, a single turn unfolds across 252 dice outcomes and 462 keep decisions.</p></div>
      <div class="step" data-step="4"><p>The solver computes the exact optimal decision for every one of these states. The result fits in 8 megabytes.</p></div>
    </div>
  </div>

  <h3>Pruning by Reachability</h3>

  <p>
    Not every slot in this grid corresponds to a position that can actually arise
    in play. An upper score of 60, for example, cannot occur if only Ones and Twos
    have been scored. A forward pass from the starting state (upper = 0, scored = empty)
    identifies exactly which states are reachable. The result is striking: 31.8% of
    slots are pruned, leaving roughly 1,430,000 states that the solver must evaluate.
    This pruning is not an approximation &mdash; it is exact, and it reduces both
    computation time and memory proportionally.
  </p>

  <div class="chart-container" id="chart-reachability-pruning">
    <div id="chart-reachability-pruning-svg"></div>
  </div>

  <h3>Dice and Decisions</h3>

  <p>
    Within each turn, the player faces a different combinatorial landscape. Five
    six-sided dice produce 6<sup>5</sup> = 7,776 ordered outcomes, but only 252
    distinct unordered results (since the order of dice does not matter). After
    seeing the dice, the player chooses which to keep &mdash; a subset of the
    current roll. The number of distinct
    <span class="concept" data-concept="keep-multiset">keep-multisets</span> is
    462, each representing a unique combination of held dice values. Every keep
    choice leads to a probability distribution over the next roll's 252 outcomes,
    which the solver evaluates exhaustively.
  </p>

  <p>
    The full decision tree within a single turn is therefore: see 252 possible dice
    outcomes, choose among up to 462 keeps, observe a new outcome, choose again,
    then assign to one of the remaining categories. This tree is evaluated at every
    reachable state, and the optimal action is stored in a strategy table for
    instant lookup during play.
  </p>

  <h3>Anatomy of a Hard Decision</h3>

  <p>
    Not all decisions are obvious. Consider this endgame position — most players
    take the safe guaranteed score, but the solver sees further.
  </p>

  <div class="chart-container" id="chart-decision-anatomy">
    <div id="chart-decision-anatomy-content"></div>
  </div>

  <div class="depth-2">
    <p>
      The state space forms a
      <span class="concept" data-concept="markov-decision-process">Markov decision process</span>
      with a layered directed acyclic graph structure. Each layer corresponds to a
      specific number of scored categories (the popcount of the bitmask). Transitions
      only move forward: from layer <var>k</var> (with <var>k</var> categories scored)
      to layer <var>k</var>+1. This topological ordering is what makes backward
      induction possible &mdash; we solve layer 15 trivially (the game is over),
      then work backward through layers 14, 13, &hellip;, 0.
    </p>

    <div class="equation">
      |states| = &sum;<sub><var>k</var>=0</sub><sup>15</sup>
      C(15,<var>k</var>) &times; 64 = 2,097,152
      &nbsp;&nbsp;&rarr;&nbsp;&nbsp;
      reachable &asymp; 1,430,000 &nbsp;(31.8% pruned)
    </div>

    <p>
      The 252 distinct dice outcomes correspond to multisets of size 5 drawn from
      {1,&hellip;,6}, counted by C(6+5&minus;1, 5) = C(10,5) = 252. Each outcome
      has a multiplicity weight (the number of ordered permutations that map to it),
      and the solver weights expectations accordingly.
    </p>
  </div>

  <div class="depth-3">
    <p>
      In the solver, states are indexed as <code>scored * 128 + upper</code> using a
      stride of 128 instead of 64. The extra padding (indices 64&ndash;127) duplicates
      the capped upper value, allowing branchless access when an upper-category score
      would push the total beyond 63. This topological padding eliminates a branch
      in the innermost loop at the cost of 2&times; memory (16 MB per strategy table).
    </p>
    <pre><code>// constants.rs
pub const STATE_STRIDE: usize = 128;
pub const NUM_STATES: usize = 32768 * STATE_STRIDE; // 4,194,304

#[inline(always)]
pub fn state_index(upper: usize, scored: usize) -&gt; usize {
    scored * STATE_STRIDE + upper
}</code></pre>
    <p>
      Keep-multiset deduplication maps the 2<sup>5</sup> = 32 subsets of a 5-die
      roll to at most 462 unique multisets across all 252 outcomes. The precomputed
      <code>KeepTable</code> stores the transition probabilities for each (keep, outcome)
      pair as <code>f32</code>, eliminating a costly <code>f64 &rarr; f32</code> conversion
      in the hot path.
    </p>
  </div>
</section>
