<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Delta Yatzy</title>
    <style>
        /**************************************************
         * Flash-of-Unstyled-Content Prevention
         **************************************************/
        body {
            margin: 0;
            padding: 0;
            opacity: 0; /* Hide initially */
        }

        body.loaded {
            opacity: 1; /* Show everything once loaded */
        }

        /**************************************************
         * Basic Page Layout
         **************************************************/
        body {
            font-family: Arial, sans-serif;
            background: #f2f2f2;
            color: #333;
            margin: 20px;
        }

        .container {
            display: flex;
            align-items: flex-start;
            gap: 20px;
        }

        /* Fixed width on the left to prevent resizing */
        .column {
            flex: 0 0 500px;
        }

        .right-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        h1 {
            margin-bottom: 10px;
        }

        h2 {
            margin-bottom: 5px;
            font-size: 1.1em;
            color: #555;
        }

        h3 {
            margin-bottom: 2px;
            font-size: 1em;
            color: #555;
        }

        /**************************************************
         * Scorecard Table
         **************************************************/
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
            background: #fff;
        }

        th,
        td {
            border: 1px solid #ccc;
            padding: 4px 5px;
            text-align: center;
        }

        th {
            background: #e0e0e0;
            border: 2px solid #000;
        }

        tr {
            border: 2px solid #ccc;
        }

        button {
            cursor: pointer; /* Changes cursor to pointer */
        }

        /* Row Colors */
        tr.scored-category {
            background-color: #d4edda; /* Light green for scored rows */
        }

        tr.available-category {
            background-color: #ffffff; /* Default white for available rows */
        }

        tr.invalid-category {
            background-color: #d1d1d1; /* Light gray for unavailable rows */
            color: #6c757d; /* Muted text color */
        }

        .bonus-row,
        .total-row {
            border-top: 2px solid #000 !important;
            border-bottom: 2px solid #000 !important;
        }

        /* Locked Best Score */
        .best-score-cell.locked {
            font-weight: bold;
            color: #333;
        }

        .best-score-cell {
            width: 50px;
            text-align: center;
            font-weight: bold;
        }

        .optimal-category {
            border: 2px solid #555 !important;
        }

        .evaluate-button {
            background: #6d88b3;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .evaluate-button:disabled {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
        }

        .scored-check {
            cursor: pointer; /* Changes cursor to pointer */
        }

        .evaluate-button:hover {
            background: #53688a;
        }

        /**************************************************
         * Right Sections
         **************************************************/
        .right-section {
            width: 700px;
            border: 1px solid #ccc;
            background: #fff;
            border-radius: 5px;
            padding: 10px;
        }

        /**************************************************
         * Dice & Rerolls
         **************************************************/
        .dice-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 5px;
            align-items: flex-start;
        }

        #randomizeDiceButton {
            margin-bottom: 10px;
        }

        .die {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            width: 100px;
            height: 120px;
            border: 2px solid #999;
            border-radius: 5px;
            background: #fff;
            padding: 5px;
            box-sizing: border-box;
            position: relative;
        }

        .die-value {
            font-size: 1.2em;
            margin: 3px 0;
            border: 1px solid #333;
            width: 44px;
            height: 44px;
            line-height: 44px;
            text-align: center;
            background: #fafafa;
        }

        .die button {
            background: #ccc;
            border: 1px solid #999;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            color: #333;
            width: 44px;
            height: 24px;
            margin: 0;
            padding: 0;
        }

        .die.locked {
            border-color: red;
        }

        .die.reroll {
            border-color: green;
        }

        .dice-reroll-button {
            width: 90%;
            max-width: 120px;
            margin-top: 8px;
            border: 1px solid #999;
            border-radius: 3px;
            font-size: 0.9em;
            cursor: pointer;
            padding: 5px;
            text-align: center;
            background: #ccc;
            color: #333;
        }

        .dice-reroll-button.locked {
            background: red;
            color: white;
        }

        .dice-reroll-button.reroll {
            background: green;
            color: white;
        }

        .dice-note {
            font-size: 0.9em;
            color: #555;
            margin-bottom: 10px;
        }

        .rerolls-container {
            margin-top: 10px;
            margin-bottom: 10px;
            text-align: left;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .rerolls-container span {
            font-weight: bold;
        }

        #rerollsRemaining {
            width: 50px;
            text-align: center;
            border: 1px solid #999;
            border-radius: 3px;
            background: #fff;
        }

        .arrow-button {
            background: #ccc;
            border: 1px solid #999;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            color: #333;
            width: 36px;
            height: 24px;
            padding: 0;
        }

        .arrow-button:hover {
            background: #bbb;
        }

        /**************************************************
         * User Action & Evaluation
         **************************************************/
        #user_action {
            height: 100px;
            border: 1px solid #999;
            border-radius: 5px;
            background: #f9f9f9;
            margin-bottom: 5px;
            padding: 5px;
            width: 500px;
        }

        #user_action_evaluation {
            border: 1px solid #ccc;
            padding: 10px;
            min-height: 50px;
            border-radius: 5px;
            background: #f9f9f9;
        }

        /**************************************************
         * Difference Box
         **************************************************/
        #difference_box {
            display: block;
            padding: 10px;
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        #differenceContent {
            font-weight: bold;
            min-height: 20px;
        }

        /**************************************************
         * Optimal Action Box (Collapsible)
         **************************************************/
        #optimalActionBox {
            display: block;
            overflow: hidden;
            max-height: 0; /* collapsed by default */
            margin-top: 0;
            padding: 0;
            border: 0;
            border-radius: 5px;
            background: #f9f9f9;
        }

        #optimalActionBox.show {
            max-height: 500px; /* expand */
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ccc;
        }

        #toggleOptimalActionButton {
            display: block;
            background: #ccc;
            border: 1px solid #999;
            border-radius: 3px;
            padding: 5px 5px;
            cursor: pointer;
        }

        #toggleOptimalActionButton:hover {
            background: #bbb;
        }

        .sorted-dice-container {
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        /**************************************************
         * Debug Box - Hidden by default with .hidden
         **************************************************/

        #toggleDebugButton {
            display: block;
            background: #ccc;
            border: 1px solid #999;
            border-radius: 3px;
            padding: 5px 5px;
            cursor: pointer;
        }

        #debugBox {
            border: 1px solid #ccc;
            border-radius: 5px;
            background: #fafafa;
            padding: 10px;
            margin-top: 10px;
        }

        #debugBox textarea {
            width: 100%;
            height: 150px;
            background: #fff;
            margin-bottom: 10px;
            border: 1px solid #999;
            border-radius: 3px;
            padding: 5px;
        }

        #toggleDebugButton:hover {
            background: #bbb;
        }

        .hidden {
            display: none !important;
        }

        /**************************************************
         * Reroll highlight
         **************************************************/
        .reroll-highlight {
            background-color: yellow;
        }

        /**************************************************
         * Histogram
         **************************************************/
        #histogramContainer {
            margin-top: 20px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
        }
    </style>

    <!-- (1) Include Chart.js from a CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<h1>&Delta; Yatzy</h1>
<div class="container">
    <!-- Scorecard Column -->
    <div class="scorecard">
        <h2>Scorecard</h2>
        <table id="scorecard">
            <thead>
            <tr>
                <th>Category</th>
                <th>Scored</th>
                <th>Score</th>
                <th>User Action</th>
            </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <!-- Right Column -->
    <div class="right-column">
        <div class="player-selection">
            <label for="playerSelect">Select Player:</label>
            <select id="playerSelect"></select>
            <button id="addPlayerButton">Add Player</button>
            <button id="resetGameButton">Reset Game</button>
        </div>

        <!-- Dice & Rerolls -->
        <div class="right-section">
            <button id="randomizeDiceButton">Randomize Dice</button>
            <div class="dice-container" id="diceContainer"></div>
            <button id="rerollDiceButton">Reroll Dice</button>

            <div class="rerolls-container">
                <span>Rerolls Remaining:</span>
                <input type="number" id="rerollsRemaining" value="2" readonly>
                <button class="arrow-button" id="reroll_down">▼</button>
                <button class="arrow-button" id="reroll_up">▲</button>
            </div>
        </div>

        <!-- User Action Evaluation -->
        <div class="right-section">
            <div id="user_action_evaluation"></div>
        </div>

        <!-- The difference box (always visible, but can show "Not available yet") -->
        <div class="right-section" id="difference_box">
            <div id="differenceContent"></div>
        </div>

        <!-- (2) Add a container + canvas for the histogram -->
        <div class="right-section" id="histogramContainer">
            <canvas id="histogramChart" width="600" height="300"></canvas>
        </div>

        <div id="game_status"></div>

        <!-- Optimal Action box with one toggle button -->
        <div class="right-section">
            <button id="toggleOptimalActionButton">Show Optimal Action</button>
            <div id="optimalActionBox">
                <h2>Optimal Action</h2>
                <div id="optimalActionContent" style="min-height:50px; margin-top:10px;"></div>

                <h2>Sorted Dice</h2>
                <div class="sorted-dice-container" id="sorted_dice_container"></div>
                <p>Yellow dice should be rerolled.</p>
            </div>
        </div>

        <!-- Debug Info (hidden by default) -->
        <div class="right-section">
            <button id="toggleDebugButton">Show Debug Info</button>
            <div id="debugBox" class="hidden">
                <h2>Debug Info</h2>
                <textarea id="rawOptimalAction" readonly></textarea>
                <textarea id="rawEvaluateAction" readonly></textarea>
                <textarea id="user_action" readonly></textarea>
            </div>
        </div>
    </div>
</div>

<script>
    /****************************************************************
     Single-File Yatzy UI with Multiplayer Support Integrated
     ****************************************************************/
    /* Configuration */
    const YAHTZEE_CATEGORIES = [
        "Ones", "Twos", "Threes", "Fours", "Fives", "Sixes",
        "One Pair", "Two Pairs", "Three of a Kind", "Four of a Kind",
        "Small Straight", "Large Straight", "Full House", "Chance", "Yatzy"
    ];
    const TOTAL_DICE = 5;
    const API_BASE_URL = "http://localhost:8080";
    const URL_AVAILABLE_CATEGORIES = `${API_BASE_URL}/available_categories`;
    const URL_SUGGEST_OPTIMAL_ACTION = `${API_BASE_URL}/suggest_optimal_action`;
    const URL_EVALUATE_USER_ACTION = `${API_BASE_URL}/evaluate_user_action`;
    const URL_EVALUATE_ACTIONS = `${API_BASE_URL}/evaluate_actions`;

    /* --- Multiplayer State --- */
    let players = [];
    let activePlayerIndex = 0;

    /* Instead of global single diceValues etc., each player will have their own state.
       We'll provide helper functions to read/write from the active player's state. */
    function getActivePlayer() {
        if (activePlayerIndex < 0 || activePlayerIndex >= players.length) {
            console.warn("Invalid activePlayerIndex:", activePlayerIndex);
            return null;
        }
        return players[activePlayerIndex];
    }

    /* DOM References */
    const playerSelect = document.getElementById("playerSelect");
    const addPlayerButton = document.getElementById("addPlayerButton");
    const scorecardBodyElement = document.querySelector("#scorecard tbody");
    const diceContainerElement = document.getElementById("diceContainer");
    const rerollCountInput = document.getElementById("rerollsRemaining");
    const differenceBoxContent = document.getElementById("differenceContent");
    const optimalActionContainer = document.getElementById("optimalActionBox");
    const optimalActionContentElement = document.getElementById("optimalActionContent");
    const toggleOptimalButton = document.getElementById("toggleOptimalActionButton");
    const debugInfoBox = document.getElementById("debugBox");
    const toggleDebugButtonElement = document.getElementById("toggleDebugButton");
    const rawOptimalActionTextArea = document.getElementById("rawOptimalAction");
    const rawEvaluateActionTextArea = document.getElementById("rawEvaluateAction");
    const userActionTextArea = document.getElementById("user_action");
    const userActionEvaluationArea = document.getElementById("user_action_evaluation");

    /* For backward compatibility, keep a global reference to diceValues.
       We'll keep it in sync with the active player's dice state. */
    let diceValues = [2, 2, 2, 5, 5];
    let optimalRerollMask = [];
    let lastOptimalExpectedValue = null;
    let lastUserExpectedValue = null;
    let currentOptimalCategoryID = null;

    /****************************************************************
     * Dice Value Update - Single Pathway
     ****************************************************************/
    function updateDiceValue(index, newValue) {
        const currentPlayer = getActivePlayer();
        if (!currentPlayer) {
            console.warn("No active player to update dice value.");
            return;
        }

        // Update the active player's dice array
        currentPlayer.diceValues[index] = newValue;

        // Keep the global diceValues in sync
        diceValues[index] = newValue;

        // Update the UI for the specific die
        const dieElement = diceContainerElement.querySelectorAll('.die')[index];
        if (dieElement) {
            const valueElement = dieElement.querySelector('.die-value');
            if (valueElement) {
                valueElement.textContent = newValue;
            }
        }
    }

    /* --- Player Management Logic --- */
    function createDefaultPlayer(name) {
        return {
            name: name || `Player ${players.length + 1}`,
            diceValues: Array(TOTAL_DICE).fill(1),
            rerollsRemaining: 2,
            optimalRerollMask: Array(TOTAL_DICE).fill("0"),
            scorecard: []
        };
    }

    function addPlayer() {
        players.push(createDefaultPlayer(`Player ${players.length + 1}`));
        updatePlayerDropdown();
    }

    function updatePlayerDropdown() {
        playerSelect.innerHTML = players
            .map((p, index) => `<option value="${index}">${p.name}</option>`)
            .join("");
    }

    function savePlayerState() {
        const currentPlayer = getActivePlayer();
        if (!currentPlayer) return;

        // Save dice values (from UI)
        const dieValueDivs = diceContainerElement.querySelectorAll(".die-value");
        currentPlayer.diceValues = Array.from(dieValueDivs).map(div => parseInt(div.textContent, 10));

        // Save rerolls
        currentPlayer.rerollsRemaining = parseInt(rerollCountInput.value, 10);

        // Save scored categories
        currentPlayer.scorecard = Array.from(document.querySelectorAll(".scored-check")).map(chk => {
            const catId = parseInt(chk.dataset.catId, 10);
            const isChecked = chk.checked;
            const scoreCell = document.querySelector(`.best-score-cell[data-cat-id="${catId}"]`);
            const score = isChecked ? parseInt(scoreCell.textContent, 10) || 0 : 0;
            return {catId, isChecked, score};
        });
    }

    function loadPlayerState() {
        const currentPlayer = getActivePlayer();
        if (!currentPlayer) return;

        // If no scorecard, initialize
        if (!currentPlayer.scorecard) {
            currentPlayer.scorecard = [];
        }

        // Load dice values
        rerollCountInput.value = currentPlayer.rerollsRemaining;
        renderDiceUI();

        // Load scored categories
        document.querySelectorAll(".scored-check").forEach(chk => {
            const catId = parseInt(chk.dataset.catId, 10);
            const scoreCell = document.querySelector(`.best-score-cell[data-cat-id="${catId}"]`);
            const scoreData = currentPlayer.scorecard.find(item => item.catId === catId) || {};

            if (scoreData.isChecked) {
                chk.checked = true;
                scoreCell.textContent = scoreData.score || "0";
                const row = chk.closest("tr");
                row.classList.add("scored-category");
                row.classList.remove("available-category", "invalid-category");
                scoreCell.classList.add("locked");
            } else {
                chk.checked = false;
                scoreCell.textContent = "0";
                const row = chk.closest("tr");
                row.classList.remove("scored-category");
                scoreCell.classList.remove("locked");
            }
        });

        refreshUI();
    }

    /* Scorecard Creation */
    function createScorecard() {
        YAHTZEE_CATEGORIES.forEach((category, i) => {
            const tr = document.createElement("tr");
            tr.dataset.catId = i;
            tr.innerHTML = `
                <td>${category}</td>
                <td>
                    <input type="checkbox" class="scored-check" data-cat-id="${i}">
                </td>
                <td class="best-score-cell" data-cat-id="${i}">0</td>
                <td>
                    <button class="evaluate-button" data-cat-id="${i}">Evaluate</button>
                </td>
            `;
            scorecardBodyElement.appendChild(tr);
        });

        // Bonus row (insert before index 6)
        const bonusTr = document.createElement("tr");
        bonusTr.classList.add("bonus-row");
        bonusTr.innerHTML = `
            <td>Upper Bonus</td>
            <td></td>
            <td class="best-score-cell bonus-best-score">0</td>
            <td></td>
        `;
        scorecardBodyElement.insertBefore(bonusTr, scorecardBodyElement.children[6]);

        // Total row (at the end)
        const totalTr = document.createElement("tr");
        totalTr.classList.add("total-row");
        totalTr.innerHTML = `
            <td>Total Score</td>
            <td></td>
            <td class="best-score-cell total-best-score">0</td>
            <td></td>
        `;
        scorecardBodyElement.appendChild(totalTr);
    }

    /* Dice UI Rendering */
    function renderDiceUI() {
        const currentPlayer = getActivePlayer();
        if (!currentPlayer || !currentPlayer.diceValues) {
            console.warn("No active player or diceValues found.");
            return;
        }

        // Clear the dice container and rebuild the dice elements
        diceContainerElement.innerHTML = ""; // No need to clone/replace

        currentPlayer.diceValues.forEach((value, index) => {
            const dieDiv = document.createElement("div");
            dieDiv.classList.add("die", "locked"); // Default state
            dieDiv.innerHTML = `
            <button class="die-button" data-action="increment" data-index="${index}">▲</button>
            <div class="die-value">${value}</div>
            <button class="die-button" data-action="decrement" data-index="${index}">▼</button>
            <button data-action="toggle" data-index="${index}" class="dice-reroll-button locked">Locked</button>
        `;
            diceContainerElement.appendChild(dieDiv);
        });
    }

    function handleIncrement(index) {
        const currentPlayer = getActivePlayer();
        if (!currentPlayer) return;
        const currentValue = currentPlayer.diceValues[index];
        const newValue = Math.min(6, currentValue + 1);

        // Single pathway to update dice value
        updateDiceValue(index, newValue);

        refreshUserActionJSON();
        refreshAvailableCategories();
        refreshUI();
    }

    function handleDecrement(index) {
        const currentPlayer = getActivePlayer();
        if (!currentPlayer) return;
        const currentValue = currentPlayer.diceValues[index];
        const newValue = Math.max(1, currentValue - 1);

        // Single pathway to update dice value
        updateDiceValue(index, newValue);

        refreshUserActionJSON();
        refreshAvailableCategories();
        refreshUI();
    }

    /** Toggle locked/reroll state. */
    function toggleDieState(index, buttonElement) {
        const currentPlayer = getActivePlayer();
        const dieContainer = buttonElement.closest(".die");
        if (!currentPlayer || !dieContainer) return;

        // Toggle the reroll/locked state
        if (buttonElement.classList.contains("locked")) {
            buttonElement.classList.remove("locked");
            buttonElement.classList.add("reroll");
            buttonElement.textContent = "Reroll";
            dieContainer.classList.remove("locked");
            dieContainer.classList.add("reroll");
            currentPlayer.optimalRerollMask[index] = "1";
        } else {
            buttonElement.classList.remove("reroll");
            buttonElement.classList.add("locked");
            buttonElement.textContent = "Locked";
            dieContainer.classList.remove("reroll");
            dieContainer.classList.add("locked");
            currentPlayer.optimalRerollMask[index] = "0";
        }

        refreshUserActionJSON();
        refreshAvailableCategories();
        refreshUI();
    }

    /* Attach Event Handlers */
    function attachEventHandlers() {
        // Centralized Event Listener for Dynamic and Static Elements
        document.body.addEventListener("click", (event) => {
            const button = event.target.closest("button");

            if (!button) return; // Ignore clicks outside buttons

            // Handle dice actions (increment, decrement, toggle)
            if (button.classList.contains("die-button") || button.classList.contains("dice-reroll-button")) {
                const action = button.dataset.action; // e.g., increment, decrement, toggle
                const index = parseInt(button.dataset.index, 10); // Dice index
                if (isNaN(index) || !action) return;

                switch (action) {
                    case "increment":
                        handleIncrement(index);
                        break;
                    case "decrement":
                        handleDecrement(index);
                        break;
                    case "toggle":
                        toggleDieState(index, button);
                        break;
                    default:
                        console.warn(`Unhandled dice action: ${action}`);
                }
                return; // Avoid further processing
            }

            // Handle Reroll actions
            if (button.id === "reroll_down" || button.id === "reroll_up") {
                const currentPlayer = getActivePlayer();
                if (!currentPlayer) return;

                if (button.id === "reroll_down") {
                    currentPlayer.rerollsRemaining = Math.max(0, currentPlayer.rerollsRemaining - 1);
                } else if (button.id === "reroll_up") {
                    currentPlayer.rerollsRemaining = Math.min(2, currentPlayer.rerollsRemaining + 1);
                }

                rerollCountInput.value = currentPlayer.rerollsRemaining;
                refreshAvailableCategories();
                refreshUI();
                return;
            }

            // Handle Evaluate Category actions
            if (button.classList.contains("evaluate-button")) {
                const categoryId = parseInt(button.dataset.catId, 10);
                if (isNaN(categoryId)) {
                    console.warn("Invalid categoryId:", button.dataset.catId);
                    return;
                }

                handleUserActionCategoryClick(categoryId);
                return;
            }

            // Handle other buttons by ID
            switch (button.id) {
                case "resetGameButton":
                    resetGame();
                    break;
                case "rerollDiceButton":
                    const currentPlayer = getActivePlayer();
                    if (!currentPlayer) return;
                    const r = currentPlayer.rerollsRemaining;
                    if (r > 0) {
                        const diceDivs = document.querySelectorAll(".die");
                        diceDivs.forEach((div, idx) => {
                            const rerollBtn = div.querySelector(".dice-reroll-button");
                            if (rerollBtn.classList.contains("reroll")) {
                                const newVal = Math.floor(Math.random() * 6) + 1;
                                updateDiceValue(idx, newVal);
                            }
                        });
                        currentPlayer.rerollsRemaining = r - 1;
                        rerollCountInput.value = currentPlayer.rerollsRemaining;
                        refreshAvailableCategories();
                        refreshUI();
                    }
                    break;
                case "randomizeDiceButton":
                    const player = getActivePlayer();
                    if (!player) return;

                    player.rerollsRemaining = 2;
                    rerollCountInput.value = player.rerollsRemaining;

                    const diceDivs = document.querySelectorAll(".die");
                    diceDivs.forEach((div, index) => {
                        const newValue = Math.floor(Math.random() * 6) + 1;
                        updateDiceValue(index, newValue);

                        const rerollBtn = div.querySelector(".dice-reroll-button");
                        rerollBtn.classList.remove("reroll");
                        rerollBtn.classList.add("locked");
                        rerollBtn.textContent = "Locked";

                        div.classList.remove("reroll");
                        div.classList.add("locked");
                    });

                    refreshAvailableCategories();
                    refreshUI();
                    break;
                case "toggleOptimalActionButton":
                    handleOptimalActionToggle();
                    break;
                case "toggleDebugButton":
                    handleDebugToggle();
                    break;
                default:
                    console.warn(`Unhandled button click: ${button.id}`);
            }
        });

        // Player selection dropdown (static element)
        playerSelect.addEventListener("change", () => {
            savePlayerState();
            activePlayerIndex = parseInt(playerSelect.value, 10);
            loadPlayerState();
        });

        // Add Player button (static element)
        addPlayerButton.addEventListener("click", () => {
            savePlayerState();
            addPlayer();
            updatePlayerDropdown();
            activePlayerIndex = players.length - 1;
            playerSelect.value = activePlayerIndex;
            loadPlayerState();
        });

        // Scorecard checkbox events
        scorecardBodyElement.addEventListener("change", (event) => {
            const checkbox = event.target.closest(".scored-check");
            if (!checkbox) return;
            handleScoreCheckboxChange(event);
        });
    }

    /* Reset Game */
    function resetGame() {
        localStorage.removeItem("yatzyGameState");

        // Reset global state
        players = [createDefaultPlayer("Player 1")];
        activePlayerIndex = 0;
        diceValues = Array(TOTAL_DICE).fill(1);
        optimalRerollMask = [];
        lastOptimalExpectedValue = null;
        lastUserExpectedValue = null;
        currentOptimalCategoryID = null;

        // Clear and rebuild UI
        scorecardBodyElement.innerHTML = "";
        createScorecard();
        updatePlayerDropdown();
        playerSelect.value = 0;
        rerollCountInput.value = 2;
        userActionEvaluationArea.innerHTML = "";
        differenceBoxContent.innerHTML = "Not available yet";
        rawOptimalActionTextArea.value = "";
        rawEvaluateActionTextArea.value = "";
        userActionTextArea.value = "";
        optimalActionContainer.classList.remove("show");
        toggleOptimalButton.textContent = "Show Optimal Action";
        optimalActionContainer.dataset.info = "None";
        optimalActionContentElement.innerHTML = "";
        debugInfoBox.classList.add("hidden");
        toggleDebugButtonElement.textContent = "Show Debug Info";
        const gameStatus = document.getElementById("game_status");
        if (gameStatus) {
            gameStatus.innerHTML = "";
        }

        // Rebuild dice UI
        renderDiceUI();

        // Randomize dice for fresh start
        document.getElementById("randomizeDiceButton").click();

        // Final UI refresh
        refreshUI();
    }

    /* Check if game is over */
    function checkIfGameIsOver() {
        const scoredCount = document.querySelectorAll(".scored-check:checked").length;
        return scoredCount === YAHTZEE_CATEGORIES.length;
    }

    /* Score handling */
    function handleScoreCheckboxChange() {
        const catId = parseInt(this.dataset.catId, 10);
        const scoreCell = document.querySelector(`.best-score-cell[data-cat-id="${catId}"]`);
        const row = this.closest("tr");

        if (this.checked) {
            const bestScoreValue = parseInt(scoreCell.textContent, 10) || 0;
            scoreCell.textContent = bestScoreValue;
            scoreCell.classList.add("locked");
            row.classList.add("scored-category");
            row.classList.remove("available-category", "invalid-category");

            getActivePlayer().rerollsRemaining = 2;
            rerollCountInput.value = getActivePlayer().rerollsRemaining;

            userActionTextArea.value = JSON.stringify(
                {
                    action: "scored",
                    category: {id: catId, name: YAHTZEE_CATEGORIES[catId]},
                    score: bestScoreValue,
                },
                null,
                2
            );
            console.log(userActionTextArea.value);
        } else {
            row.classList.remove("scored-category");
            row.classList.add("available-category");
            scoreCell.classList.remove("locked");

            userActionTextArea.value = JSON.stringify(
                {
                    action: "unscored",
                    category: {id: catId, name: YAHTZEE_CATEGORIES[catId]},
                },
                null,
                2
            );
        }

        recalculateScores();
        refreshAvailableCategories();
        refreshUI();
        saveGameState(); // Save state after scoring
    }

    function handleUserActionCategoryClick(categoryId) {
        // Ensure categoryId is a valid number
        const numericCategoryId = parseInt(categoryId, 10);
        if (isNaN(numericCategoryId)) {
            console.error("Invalid categoryId passed:", categoryId);
            return;
        }

        const currentPlayer = getActivePlayer();
        if (!currentPlayer) {
            console.error("No active player available.");
            return;
        }

        if (checkIfGameIsOver()) {
            console.warn("Game is over. Cannot evaluate category.");
            return;
        }

        const rerollsRemaining = parseInt(rerollCountInput.value, 10);
        if (rerollsRemaining !== 0) {
            console.warn("Cannot evaluate category while rerolls remain.");
            return;
        }

        // Locate the row in the scorecard corresponding to the category
        const categoryRow = document.querySelector(`tr[data-cat-id="${numericCategoryId}"]`);
        if (!categoryRow || categoryRow.classList.contains("invalid-category")) {
            console.warn(`Category ${numericCategoryId} is invalid or not available.`);
            return;
        }

        // Update the user action text area with the selected category
        userActionTextArea.value = JSON.stringify(
            {
                best_category: {
                    id: numericCategoryId,
                    name: YAHTZEE_CATEGORIES[numericCategoryId],
                },
            },
            null,
            2
        );

        console.log(userActionTextArea.value);

        // Refresh UI after the category evaluation
        refreshUI();
    }

    /* UI Refresh / Lifecycle */
    async function refreshUI() {
        if (checkIfGameIsOver()) {
            const totalScore = calculateFinalScore();
            document.getElementById("game_status").innerHTML = `
                <h2>Game Finished!</h2>
                <p>Total Score: <strong>${totalScore}</strong></p>
            `;
            localStorage.removeItem("yatzyGameState");
            return;
        }

        recalculateScores();
        refreshUserActionJSON();
        await refreshAvailableCategories();
        await refreshOptimalAction();
        await evaluateUserActionSelection();
        displaySortedDice();
        refreshRerollButton();
        refreshDifferenceBox();

        // Enable/Disable Evaluate buttons
        const r = getActivePlayer().rerollsRemaining;
        document.querySelectorAll(".evaluate-button").forEach((button) => {
            button.disabled = r !== 0;
        });

        // Save state after every UI update
        saveGameState();
    }

    function calculateFinalScore() {
        let totalScore = 0;
        let upperScoreSum = 0;

        document.querySelectorAll(".scored-check:checked").forEach((checkbox) => {
            const catId = parseInt(checkbox.dataset.catId, 10);
            const scoreCell = document.querySelector(`.best-score-cell[data-cat-id="${catId}"]`);
            const scoreValue = parseInt(scoreCell.textContent, 10) || 0;
            totalScore += scoreValue;
            if (catId <= 5) {
                upperScoreSum += scoreValue;
            }
        });

        if (upperScoreSum >= 63) {
            totalScore += 50;
        }
        return totalScore;
    }

    function recalculateScores() {
        let totalScore = 0;
        let upperScoreSum = 0;

        document.querySelectorAll(".scored-check").forEach((checkbox) => {
            if (checkbox.checked) {
                const catId = parseInt(checkbox.dataset.catId, 10);
                const scoreCell = document.querySelector(`.best-score-cell[data-cat-id="${catId}"]`);
                const scoreValue = parseInt(scoreCell.textContent, 10) || 0;

                totalScore += scoreValue;
                if (catId <= 5) {
                    upperScoreSum += scoreValue;
                }
            }
        });

        const bonus = upperScoreSum >= 63 ? 50 : 0;
        const bonusCell = document.querySelector(".bonus-best-score");
        if (bonusCell) bonusCell.textContent = upperScoreSum;
        const totalCell = document.querySelector(".total-best-score");
        if (totalCell) totalCell.textContent = totalScore + bonus;
    }

    function refreshUserActionJSON() {
        const r = getActivePlayer().rerollsRemaining;
        let ua = {};
        try {
            ua = JSON.parse(userActionTextArea.value) || {};
        } catch (e) {
            ua = {};
        }

        if (r > 0) {
            let mask = "";
            const diceDivs = document.querySelectorAll(".die");
            diceDivs.forEach((div) => {
                const btn = div.querySelector(".dice-reroll-button");
                mask += btn.classList.contains("reroll") ? "1" : "0";
            });
            ua = {best_reroll: {mask_binary: mask}};
        } else if (!ua.best_category) {
            ua = {};
        }
        userActionTextArea.value = JSON.stringify(ua, null, 2);
    }

    function refreshRerollButton() {
        const r = getActivePlayer().rerollsRemaining;
        document.getElementById("rerollDiceButton").disabled = (r === 0);
    }

    function refreshDifferenceBox() {
        if (lastOptimalExpectedValue == null || lastUserExpectedValue == null) {
            differenceBoxContent.innerHTML = "Not available yet";
        } else {
            const diff = (lastOptimalExpectedValue - lastUserExpectedValue).toFixed(3);
            differenceBoxContent.innerHTML = "&Delta; = " + diff;
        }
    }

    /* State Saving / Restoration */
    function saveGameState() {
        const gameState = getGameStateAsJSON();
        localStorage.setItem("yatzyGameState", JSON.stringify(gameState));
    }

    function getGameStateAsJSON() {
        savePlayerState(); // Make sure we have latest from UI

        const allPlayersState = players.map(p => ({
            name: p.name,
            diceValues: [...p.diceValues],
            optimalRerollMask: [...p.optimalRerollMask],
            lastOptimalExpectedValue: p.lastOptimalExpectedValue,
            lastUserExpectedValue: p.lastUserExpectedValue,
            currentOptimalCategoryID: p.currentOptimalCategoryID,
            rerollsRemaining: p.rerollsRemaining,
            scorecard: p.scorecard
        }));

        const gameState = {
            dice: [...diceValues],
            rerolls_remaining: parseInt(rerollCountInput.value, 10),
            scored_categories: collectScoredCategoriesBitmask(),
            scored_category_scores: collectScoredCategoryScores(),
            upper_score: computeUpperScore(),
            total_score: computeTotalScore(),
            optimal_best_reroll_mask: optimalRerollMask,
            lastOptimalEV: lastOptimalExpectedValue,
            lastUserEV: lastUserExpectedValue,
            currentOptimalCategoryId: currentOptimalCategoryID,
            players: allPlayersState,
            activePlayerIndex
        };
        return gameState;
    }

    function collectScoredCategoriesBitmask() {
        let bitmask = 0;
        document.querySelectorAll(".scored-check").forEach((checkbox) => {
            if (checkbox.checked) {
                const catId = parseInt(checkbox.dataset.catId, 10);
                bitmask |= 1 << catId;
            }
        });
        return bitmask;
    }

    function collectScoredCategoryScores() {
        const scores = {};
        document.querySelectorAll(".scored-check").forEach((checkbox) => {
            if (checkbox.checked) {
                const catId = parseInt(checkbox.dataset.catId, 10);
                const scoreCell = document.querySelector(`.best-score-cell[data-cat-id='${catId}']`);
                scores[catId] = scoreCell ? parseInt(scoreCell.textContent, 10) || 0 : 0;
            }
        });
        return scores;
    }

    function computeUpperScore() {
        let upperSum = 0;
        document.querySelectorAll(".scored-check:checked").forEach((checkbox) => {
            const catId = parseInt(checkbox.dataset.catId, 10);
            const scoreCell = document.querySelector(`.best-score-cell[data-cat-id='${catId}']`);
            const val = scoreCell ? parseInt(scoreCell.textContent, 10) || 0 : 0;
            if (catId <= 5) upperSum += val;
        });
        if (upperSum >= 63) return upperSum + 50;
        return upperSum;
    }

    function computeTotalScore() {
        let totalScore = 0;
        let upperSum = 0;
        document.querySelectorAll(".scored-check:checked").forEach((checkbox) => {
            const catId = parseInt(checkbox.dataset.catId, 10);
            const scoreCell = document.querySelector(`.best-score-cell[data-cat-id='${catId}']`);
            const val = scoreCell ? parseInt(scoreCell.textContent, 10) || 0 : 0;
            totalScore += val;
        });

        document.querySelectorAll(".scored-check:checked").forEach((checkbox) => {
            const catId = parseInt(checkbox.dataset.catId, 10);
            const scoreCell = document.querySelector(`.best-score-cell[data-cat-id='${catId}']`);
            const val = scoreCell ? parseInt(scoreCell.textContent, 10) || 0 : 0;
            if (catId <= 5) upperSum += val;
        });

        if (upperSum >= 63) totalScore += 50;
        return totalScore;
    }

    function restoreGameFromState(input) {
        try {
            const state = typeof input === "string" ? JSON.parse(input) : input;

            // Scorecard
            scorecardBodyElement.innerHTML = "";
            createScorecard();

            // Restore players
            if (state.players && Array.isArray(state.players)) {
                players = state.players.map(p => ({
                    name: p.name,
                    diceValues: Array.isArray(p.diceValues) ? [...p.diceValues] : Array(TOTAL_DICE).fill(1),
                    optimalRerollMask: Array.isArray(p.optimalRerollMask) ? [...p.optimalRerollMask] : [],
                    lastOptimalExpectedValue: p.lastOptimalExpectedValue || null,
                    lastUserExpectedValue: p.lastUserExpectedValue || null,
                    currentOptimalCategoryID: p.currentOptimalCategoryID || null,
                    rerollsRemaining: typeof p.rerollsRemaining === 'number' ? p.rerollsRemaining : 2,
                    scorecard: p.scorecard || []
                }));
                activePlayerIndex = state.activePlayerIndex || 0;
            }

            // UI and load
            updatePlayerDropdown();
            playerSelect.value = activePlayerIndex;
            loadPlayerState();

            recalculateScores();
            refreshAvailableCategories();
            refreshUI();

            return true;
        } catch (error) {
            console.error('Failed to restore game state:', error);
            return false;
        }
    }

    /* Category / Reroll / Optimal */
    async function sendJSONPostRequest(url, data) {
        const response = await fetch(url, {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(data)
        });
        if (!response.ok) {
            throw new Error(`Server responded with ${response.status}`);
        }
        return response.text();
    }

    async function refreshAvailableCategories() {
        const currentData = getCurrentGameData();
        try {
            const raw = await sendJSONPostRequest(URL_AVAILABLE_CATEGORIES, currentData);
            const data = JSON.parse(raw);

            data.categories.forEach((c) => {
                const catId = c.id;
                const row = document.querySelector(`tr[data-cat-id="${catId}"]`);
                const chk = document.querySelector(`.scored-check[data-cat-id="${catId}"]`);
                const scoreCell = document.querySelector(`.best-score-cell[data-cat-id="${catId}"]`);

                if (chk.checked) {
                    row.classList.add("scored-category");
                    row.classList.remove("available-category", "invalid-category");
                    scoreCell.classList.add("locked");
                } else if (c.valid) {
                    row.classList.add("available-category");
                    row.classList.remove("scored-category", "invalid-category");
                    scoreCell.classList.remove("locked");
                    scoreCell.textContent = c.score;
                } else {
                    row.classList.add("invalid-category");
                    row.classList.remove("scored-category", "available-category");
                    scoreCell.classList.remove("locked");
                    scoreCell.textContent = "0";
                }
            });
        } catch (e) {
            console.error("Error updating available categories:", e);
        }
    }

    async function refreshOptimalAction() {
        document.querySelectorAll(".optimal-category").forEach((row) => row.classList.remove("optimal-category"));

        const currentPlayer = getActivePlayer();
        if (currentPlayer) {
            currentPlayer.optimalRerollMask = [];
            currentPlayer.lastOptimalExpectedValue = null;
            currentPlayer.lastUserExpectedValue = null;
            currentPlayer.currentOptimalCategoryID = null;
        }

        lastOptimalExpectedValue = null;
        lastUserExpectedValue = null;
        currentOptimalCategoryID = null;
        optimalRerollMask = [];

        const s = getCurrentGameData();

        try {
            const raw = await sendJSONPostRequest(URL_SUGGEST_OPTIMAL_ACTION, s);
            const data = JSON.parse(raw);
            rawOptimalActionTextArea.value = JSON.stringify(data, null, 2);

            if (data.expected_value != null) {
                lastOptimalExpectedValue = parseFloat(data.expected_value);
                if (currentPlayer) {
                    currentPlayer.lastOptimalExpectedValue = lastOptimalExpectedValue;
                }
            }

            let info = "None";
            if (s.rerolls_remaining > 0 && data.best_reroll) {
                info = `Reroll mask: ${data.best_reroll.mask_binary}<br>Expected Score: ${data.expected_value.toFixed(3)}`;
                optimalRerollMask = data.best_reroll.mask_binary.split("");
                if (currentPlayer) {
                    currentPlayer.optimalRerollMask = [...optimalRerollMask];
                }
            } else if (s.rerolls_remaining === 0 && data.best_category) {
                info = `
                    <p>Optimal Category: <strong>${data.best_category.name}</strong></p>
                    <p>Expected Value: ${data.expected_value.toFixed(3)}</p>
                `;
                currentOptimalCategoryID = data.best_category.id;
                if (currentPlayer) {
                    currentPlayer.currentOptimalCategoryID = currentOptimalCategoryID;
                }
            }

            optimalActionContainer.dataset.info = info;
            if (optimalActionContainer.classList.contains("show") && currentOptimalCategoryID != null) {
                const optimalRow = document.querySelector(`tr[data-cat-id='${currentOptimalCategoryID}']`);
                if (optimalRow) {
                    optimalRow.classList.add("optimal-category");
                }
            }
            optimalActionContentElement.innerHTML = info;
        } catch (e) {
            rawOptimalActionTextArea.value = `Error: ${e.message}`;
        }
    }

    async function evaluateUserActionSelection() {
        const s = getCurrentGameData();
        let ua = {};

        try {
            ua = JSON.parse(userActionTextArea.value);
        } catch (e) {
            userActionEvaluationArea.textContent = "No user action chosen or invalid JSON.";
            rawEvaluateActionTextArea.value = "No user action chosen or invalid JSON.";
            lastUserExpectedValue = null;
            if (getActivePlayer()) getActivePlayer().lastUserExpectedValue = null;
            return;
        }

        if (!ua || Object.keys(ua).length === 0) {
            userActionEvaluationArea.textContent = "No user action chosen.";
            rawEvaluateActionTextArea.value = "No user action chosen.";
            lastUserExpectedValue = null;
            if (getActivePlayer()) getActivePlayer().lastUserExpectedValue = null;
            return;
        }

        let diceToSend = [...getActivePlayer().diceValues];
        let newUA = JSON.parse(JSON.stringify(ua));

        if (s.rerolls_remaining > 0 && newUA.best_reroll && newUA.best_reroll.mask_binary) {
            const {dice: sortedDice, mask: newMask} = reorderDiceAndMask(diceToSend, newUA.best_reroll.mask_binary);
            diceToSend = sortedDice;
            newUA.best_reroll.mask_binary = newMask;
            newUA.best_reroll.id = convertMaskToId(newMask);
        }
        const s2 = {...s, dice: diceToSend};

        try {
            const raw = await sendJSONPostRequest(URL_EVALUATE_USER_ACTION, {
                ...s2,
                user_action: newUA,
            });
            const data = JSON.parse(raw);
            rawEvaluateActionTextArea.value = JSON.stringify(data, null, 2);

            if (data.expected_value != null) {
                lastUserExpectedValue = parseFloat(data.expected_value);
                if (getActivePlayer()) getActivePlayer().lastUserExpectedValue = lastUserExpectedValue;

                let currentScore = 0;
                document.querySelectorAll(".scored-check:checked").forEach((checkbox) => {
                    const catId = parseInt(checkbox.dataset.catId, 10);
                    const scoreCell = document.querySelector(`.best-score-cell[data-cat-id="${catId}"]`);
                    currentScore += parseInt(scoreCell.textContent, 10) || 0;
                });

                userActionEvaluationArea.innerHTML = `
                    <p><b>Expected Total Score = </b> ${(currentScore + lastUserExpectedValue).toFixed(3)}</p>
                `;
            } else {
                userActionEvaluationArea.textContent = "No user action chosen.";
                lastUserExpectedValue = null;
                if (getActivePlayer()) getActivePlayer().lastUserExpectedValue = null;
            }
        } catch (e) {
            rawEvaluateActionTextArea.value = `Error: ${e.message}`;
            userActionEvaluationArea.textContent = `Error evaluating user action: ${e.message}`;
            lastUserExpectedValue = null;
            if (getActivePlayer()) getActivePlayer().lastUserExpectedValue = null;
        } finally {
            await updateHistogram();
        }
    }

    /* Histogram & Chart.js */
    let histogramChart = null;

    async function getCachedHistogramData() {
        const CACHE_KEY = 'histogram_cache';
        const CACHE_DURATION = 60 * 60 * 1000;

        try {
            const cached = localStorage.getItem(CACHE_KEY);
            if (cached) {
                const {timestamp, data} = JSON.parse(cached);
                if (Date.now() - timestamp < CACHE_DURATION) {
                    return data;
                }
            }
            const response = await fetch('http://localhost:8080/score_histogram');
            const data = await response.json();
            localStorage.setItem(CACHE_KEY, JSON.stringify({
                timestamp: Date.now(),
                data
            }));
            return data;
        } catch (error) {
            console.error('Error fetching histogram data:', error);
            return null;
        }
    }

    async function updateHistogram() {
        const currentData = getCurrentGameData();
        try {
            const [actionResponse, histogramResponse] = await Promise.all([
                sendJSONPostRequest(URL_EVALUATE_ACTIONS, currentData),
                getCachedHistogramData()
            ]);

            if (!histogramResponse) {
                console.warn("No histogram data available");
                return;
            }

            const responseData = JSON.parse(actionResponse);
            const allEvs = [];
            responseData.actions.forEach((action) => {
                if (action.distribution) {
                    action.distribution.forEach((dist) => {
                        allEvs.push(dist.ev + currentData.total_score);
                    });
                }
            });

            if (allEvs.length === 0) {
                console.warn("No expected values found in response.");
                if (histogramChart) {
                    histogramChart.destroy();
                    histogramChart = null;
                }
                return;
            }

            const minEV = 100;
            const maxEV = 380;
            const binCount = 56;
            const binWidth = (maxEV - minEV) / binCount;
            const currentBins = Array(binCount).fill(0);

            allEvs.forEach((val) => {
                const index = Math.min(Math.floor((val - minEV) / binWidth), binCount - 1);
                if (index >= 0) currentBins[index]++;
            });

            const labels = Array.from({length: binCount}, (_, i) => {
                const start = Math.round(minEV + i * binWidth);
                const end = Math.round(start + binWidth);
                return `${start.toFixed(0)} - ${end.toFixed(0)}`;
            });

            const ctx = document.getElementById("histogramChart");
            if (!ctx) {
                console.error("Histogram canvas not found in DOM.");
                return;
            }

            const chartConfig = {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "10k Optimal",
                            data: histogramResponse.bins,
                            backgroundColor: "rgba(40, 150, 250, 0.1)",
                            borderColor: "rgba(40, 150, 250, 0.3)",
                            borderWidth: 1,
                        },
                        {
                            label: "Current Expected Values",
                            data: currentBins,
                            backgroundColor: "rgba(255, 100, 40, 0.9)",
                            borderColor: "rgba(255, 100, 40, 1)",
                            borderWidth: 1,
                        }
                    ]
                },
                options: {
                    responsive: true,
                    animation: false,
                    transitions: {
                        active: {
                            animation: {duration: 0}
                        }
                    },
                    scales: {
                        x: {
                            title: {display: true, text: "Expected Value Range"}
                        },
                        y: {
                            title: {display: true, text: "Frequency"},
                            min: 0,
                            max: 1000
                        }
                    }
                }
            };

            if (!histogramChart) {
                histogramChart = new Chart(ctx.getContext("2d"), chartConfig);
            } else {
                histogramChart.data = chartConfig.data;
                histogramChart.update();
            }
        } catch (error) {
            console.error("Histogram update failed:", error);
        }
    }

    /* Dice Reordering */
    function reorderDiceAndMask(originalDice, originalMask) {
        const pairedArray = originalDice.map((v, i) => ({value: v, index: i}));
        pairedArray.sort((a, b) => a.value - b.value);

        const sortedDice = pairedArray.map((item) => item.value);
        const remappedMask = pairedArray.map((item) => originalMask[item.index]).join("");
        return {dice: sortedDice, mask: remappedMask};
    }

    function handleOptimalActionToggle() {
        if (optimalActionContainer.classList.contains("show")) {
            // Hide Optimal Action box
            optimalActionContainer.classList.remove("show");
            toggleOptimalButton.textContent = "Show Optimal Action";

            // Clear any highlighted rows for optimal categories
            document.querySelectorAll(".optimal-category").forEach(row => {
                row.classList.remove("optimal-category");
            });
        } else {
            // Show Optimal Action box
            optimalActionContainer.classList.add("show");
            toggleOptimalButton.textContent = "Hide Optimal Action";

            // Display optimal action information
            let info = optimalActionContainer.dataset.info || "None";
            optimalActionContentElement.innerHTML = info;

            // Highlight the optimal category row if one exists
            if (currentOptimalCategoryID != null) {
                const optimalRow = document.querySelector(`tr[data-cat-id='${currentOptimalCategoryID}']`);
                if (optimalRow) {
                    optimalRow.classList.add("optimal-category");
                }
            }

            // Display sorted dice and highlight those to be rerolled
            displaySortedDice();
        }
    }

    function handleDebugToggle() {
        if (debugInfoBox.classList.contains("hidden")) {
            // Show Debug Info
            debugInfoBox.classList.remove("hidden");
            toggleDebugButtonElement.textContent = "Hide Debug Info";
        } else {
            // Hide Debug Info
            debugInfoBox.classList.add("hidden");
            toggleDebugButtonElement.textContent = "Show Debug Info";
        }
    }

    function getCurrentGameData() {
        const currentPlayer = getActivePlayer();
        if (!currentPlayer) {
            console.warn("No active player. Cannot retrieve game data.");
            return null;
        }

        // Calculate scored categories as a bitmask
        let bitmask = 0;
        let total = 0;
        let upperSum = 0;

        document.querySelectorAll(".scored-check").forEach((checkbox) => {
            if (checkbox.checked) {
                const catId = parseInt(checkbox.dataset.catId, 10);
                const scoreCell = document.querySelector(`.best-score-cell[data-cat-id='${catId}']`);
                const value = scoreCell ? parseInt(scoreCell.textContent, 10) || 0 : 0;
                bitmask |= 1 << catId;
                total += value;
                if (catId <= 5) {
                    upperSum += value;
                }
            }
        });

        const bonus = upperSum >= 63 ? 50 : 0;

        return {
            upper_score: upperSum + bonus,
            scored_categories: bitmask,
            dice: [...currentPlayer.diceValues],
            rerolls_remaining: currentPlayer.rerollsRemaining,
            total_score: total + bonus
        };
    }

    function convertMaskToId(mask) {
        let id = 0;
        for (let i = 0; i < mask.length; i++) {
            if (mask[i] === "1") {
                id |= 1 << i; // Set the bit at position i
            }
        }
        return id;
    }

    function displaySortedDice() {
        const currentPlayer = getActivePlayer();
        const container = document.getElementById("sorted_dice_container");
        if (!currentPlayer || !container) {
            console.warn("No active player or container found.");
            return;
        }

        // Clear the container before displaying new dice
        container.innerHTML = "";

        // Get dice values and the reroll mask
        const diceValues = [...currentPlayer.diceValues];
        const rerollMask = currentPlayer.optimalRerollMask || [];

        // Create an array of dice with their original indices
        const sortedDice = diceValues.map((value, index) => ({value, index})).sort((a, b) => a.value - b.value);

        // Add sorted dice to the container
        sortedDice.forEach(({value, index}) => {
            const diceDiv = document.createElement("div");
            diceDiv.classList.add("die-value");
            diceDiv.textContent = value;

            // Highlight dice to be rerolled (if reroll mask indicates so)
            if (rerollMask[index] === "1") {
                diceDiv.classList.add("reroll-highlight");
            }

            container.appendChild(diceDiv);
        });
    }

    /* Lifecycle: init */
    function init() {
        // Ensure at least one default player
        if (players.length === 0) {
            players.push(createDefaultPlayer("Player 1"));
        }
        activePlayerIndex = 0;

        // Build UI
        createScorecard();
        renderDiceUI();

        attachEventHandlers();

        // Populate player dropdown
        updatePlayerDropdown();
        playerSelect.value = activePlayerIndex;

        // Attempt restore
        const savedState = localStorage.getItem("yatzyGameState");
        if (savedState) {
            try {
                restoreGameFromState(savedState);
                return;
            } catch (error) {
                console.error("Failed to load saved state:", error);
                localStorage.removeItem("yatzyGameState");
            }
        }

        // Fresh random dice if no restore
        document.getElementById("randomizeDiceButton").click();
        refreshUI();
    }

    window.addEventListener('beforeunload', () => {
        if (!checkIfGameIsOver()) {
            saveGameState();
        }
    });

    document.addEventListener("DOMContentLoaded", () => {
        init();
        document.body.classList.add("loaded");
    });
</script>
</body>
</html>